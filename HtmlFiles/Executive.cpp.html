<!---------------------------------------------------------------------
 File Name- Executive.cpp
PublishedTue Apr  4 23:49:51 2017

Author- Siri Chandana Sambatur, ssambatu@syr.edu
 ----------------------------------->
 <!DOCTYPE html><br><html><head><link rel='stylesheet' type='text/css' href='HideInformation.css'>
<link rel='stylesheet' type='text/css' href='HTMLDesign.css'>
<link rel='stylesheet' type='text/css' href='HideInformation.css'>
<link rel='stylesheet' type='text/css' href='HTMLDesign.css'>
<script src='jquery-3.2.0.js'></script><script src='HideInformation.js'></script></head><body><div class='header'>Code Publisher - Executive.cpp</div><div class='mainContent'><div class='dependancies'>List Of Dependancies-<br></div><ol class='alink' type='1'><li><a href='Executive.h.html'>Executive.h</a></li><li><a href='Display.h.html'>Display.h</a></li></ol><div id='code'><br>Code present in the file is given below-<br></div><pre>#define _CRT_SECURE_NO_WARNINGS
/////////////////////////////////////////////////////////////////////
// Executive.cpp - Directs Code Analysis                           //
// ver 1.3                                                         //
//-----------------------------------------------------------------//
// Jim Fawcett (c) copyright 2016                                  //
// All rights granted provided this copyright notice is retained   //
//-----------------------------------------------------------------//
// Language:    C++, Visual Studio 2015                            //
// Platform:    Dell XPS 8900, Windows 10                          //
// Application: Project #2, CSE687 - Object Oriented Design, S2015 //
// Source:      Jim Fawcett, Syracuse University, CST 4-187        //
//              jfawcett@twcny.rr.com                              //
// Author:      Siri Chandana Sambatur, ssambatu@syr.edu           //
/////////////////////////////////////////////////////////////////////

#include "Executive.h"
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;exception&gt;
#include &lt;iomanip&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include "../FileSystem/FileSystem.h"
#include "../Parser/ActionsAndRules.h"
#include "../AbstractSyntaxTree/AbstrSynTree.h"
#include "../Logger/Logger.h"
#include "../Display/Display.h"

using Rslt = Logging::StaticLogger&lt;0&gt;;  // use for application results
using Demo = Logging::StaticLogger&lt;1&gt;;  // use for demonstrations of processing
using Dbug = Logging::StaticLogger&lt;2&gt;;  // use for debug output


/////////////////////////////////////////////////////////////////////
// AnalFileMgr class
// - Derives from FileMgr to make application specific file handler
//   by overriding FileMgr::file(), FileMgr::dir(), and FileMgr::done()

using Path = std::string;
using File = std::string;
using Files = std::vector&lt;File&gt;;
using Pattern = std::string;
using Ext = std::string;
using FileMap = std::unordered_map&lt;Pattern, Files&gt;;

using namespace CodeAnalysis;

//----&lt; initialize application specific FileMgr &gt;--------------------
/*
 * - Accepts CodeAnalysisExecutive's path and fileMap by reference
 */
AnalFileMgr::AnalFileMgr(const Path& path, FileMap& fileMap)
  : FileMgr(path), fileMap_(fileMap), numFiles_(0), numDirs_(0) <button id="collapseInfo" onclick ="myFunction('collapsible1')">show</button><div id = "collapsible1">{}</div>

//----&lt; override of FileMgr::file(...) to store found files &gt;------

void AnalFileMgr::file(const File& f)
<button id="collapseInfo" onclick ="myFunction('collapsible2')">show</button><div id = "collapsible2">{
  File fqf = d_ + "\\" + f;
  Ext ext = FileSystem::Path::getExt(fqf);
  Pattern p = "*." + ext;
  fileMap_[p].push_back(fqf);
  ++numFiles_;
}</div>
//----&lt; override of FileMgr::dir(...) to save current dir &gt;----------

void AnalFileMgr::dir(const Dir& d)
<button id="collapseInfo" onclick ="myFunction('collapsible3')">show</button><div id = "collapsible3">{
  d_ = d;
  ++numDirs_;
}</div>
//----&lt; override of FileMgr::done(), not currently used &gt;------------

void AnalFileMgr::done()
<button id="collapseInfo" onclick ="myFunction('collapsible4')">show</button><div id = "collapsible4">{
}</div>
//----&lt; returns number of matched files from search &gt;----------------

size_t AnalFileMgr::numFiles()
<button id="collapseInfo" onclick ="myFunction('collapsible5')">show</button><div id = "collapsible5">{
  return numFiles_;
}</div>
//----&lt; returns number of dirs searched &gt;----------------------------

size_t AnalFileMgr::numDirs()
<button id="collapseInfo" onclick ="myFunction('collapsible6')">show</button><div id = "collapsible6">{
  return numDirs_;
}</div>

/////////////////////////////////////////////////////////////////////
// CodeAnalysisExecutive class
// - 
using Path = std::string;
using Pattern = std::string;
using Patterns = std::vector&lt;Pattern&gt;;
using File = std::string;
using Files = std::vector&lt;File&gt;;
using Ext = std::string;
using FileMap = std::unordered_map&lt;Pattern, Files&gt;;
using ASTNodes = std::vector&lt;ASTNode*&gt;;
using FileToNodeCollection = std::vector&lt;std::pair&lt;File, ASTNode*&gt;&gt;;

//----&lt; initialize parser, get access to repository &gt;----------------

CodeAnalysisExecutive::CodeAnalysisExecutive()
<button id="collapseInfo" onclick ="myFunction('collapsible7')">show</button><div id = "collapsible7">{
  pParser_ = configure_.Build();
  if (pParser_ == nullptr)
  <button id="collapseInfo" onclick ="myFunction('collapsible8')">show</button><div id = "collapsible8">{
    throw std::exception("couldn't create parser");
  }</div>
  pRepo_ = Repository::getInstance();
}</div>
//----&lt; cleanup &gt;----------------------------------------------------

CodeAnalysisExecutive::~CodeAnalysisExecutive()
<button id="collapseInfo" onclick ="myFunction('collapsible9')">show</button><div id = "collapsible9">{
  /*
   *  Nothing to do:
   *  - pParser_ and pRepo_ point to objects that the configure_
   *    destructor will delete.
   *  - The AbstractSynTree object will cleanup its contents when
   *    it goes out of scope by deleting the root of the AST node
   *    tree.  
   *  - Each node deletes its children, so, again, nothing more 
   *    to do.
   *  - This is here to present these comments and to make this
   *    base destructor virtual.
   */
}</div>
//----&lt; usage message &gt;----------------------------------------------

void showUsage()
<button id="collapseInfo" onclick ="myFunction('collapsible10')">show</button><div id = "collapsible10">{
  std::ostringstream out;
  out &lt;&lt; "\n  Usage:";
  out &lt;&lt; "\n  Command Line Arguments are:";
  out &lt;&lt; "\n  - 1st: path to subdirectory containing files to analyze";
  out &lt;&lt; "\n  - remaining non-option arguments are file patterns, e.g., *.h and/or *.cpp, etc.";
  out &lt;&lt; "\n  - must have at least one file pattern to specify what to process";
  out &lt;&lt; "\n  - option arguments have the format \"\"/x\" , where x is one of the options:";
  out &lt;&lt; "\n    - m : display function metrics";
  out &lt;&lt; "\n    - s : display file sizes";
  out &lt;&lt; "\n    - a : display Abstract Syntax Tree";
  out &lt;&lt; "\n    - r : set logger to display results";
  out &lt;&lt; "\n    - d : set logger to display demo outputs";
  out &lt;&lt; "\n    - b : set logger to display debug outputs";
  out &lt;&lt; "\n    - f : write all logs to logfile.txt";
  out &lt;&lt; "\n  A metrics summary is always shown, independent of any options used or not used";
  out &lt;&lt; "\n\n";
  std::cout &lt;&lt; out.str();
  //Rslt::write(out.str());
  //Rslt::flush();
}</div>
//----&lt; show command line arguments &gt;--------------------------------

void CodeAnalysisExecutive::showCommandLineArguments(int argc, char* argv[])
<button id="collapseInfo" onclick ="myFunction('collapsible11')">show</button><div id = "collapsible11">{
  std::ostringstream out;
  std::cout&lt;&lt;"\n     Path:- '"&lt;&lt; FileSystem::Path::getFullFileSpec(argv[1]) &lt;&lt; "\"\n     Args: ";
  out &lt;&lt; "\n     Path: \"" &lt;&lt; FileSystem::Path::getFullFileSpec(argv[1]) &lt;&lt; "\"\n     Args: ";
  for (int i = 2; i &lt; argc - 1; ++i) <button id="collapseInfo" onclick ="myFunction('collapsible12')">show</button><div id = "collapsible12">{
	  std::cout &lt;&lt; argv[i] &lt;&lt; ", ";
	  out &lt;&lt; argv[i] &lt;&lt; ", ";
  }</div>
  std::cout &lt;&lt; argv[argc - 1];
  out &lt;&lt; argv[argc - 1];
  Rslt::write(out.str());
  Rslt::flush();
}</div>
//----&lt; handle command line arguments &gt;------------------------------
/*
* Arguments are:
* - path: possibly relative path to folder containing all analyzed code,
*   e.g., may be anywhere in the directory tree rooted at that path
* - patterns: one or more file patterns of the form *.h, *.cpp, and *.cs
* - options: /m (show metrics), /s (show file sizes), and /a (show AST)
*/
bool CodeAnalysisExecutive::ProcessCommandLine(int argc, char* argv[])
<button id="collapseInfo" onclick ="myFunction('collapsible13')">show</button><div id = "collapsible13">{
  if (argc &lt; 2)
  <button id="collapseInfo" onclick ="myFunction('collapsible14')">show</button><div id = "collapsible14">{
    showUsage();
    return false;
  }</div>
  try <button id="collapseInfo" onclick ="myFunction('collapsible15')">show</button><div id = "collapsible15">{
    path_ = FileSystem::Path::getFullFileSpec(argv[1]);
    if (!FileSystem::Directory::exists(path_))
    <button id="collapseInfo" onclick ="myFunction('collapsible16')">show</button><div id = "collapsible16">{
      std::cout &lt;&lt; "\n\n  path \"" &lt;&lt; path_ &lt;&lt; "\" does not exist\n\n";
      return false;
    }</div>
    for (int i = 2; i &lt; argc; ++i)
    <button id="collapseInfo" onclick ="myFunction('collapsible17')">show</button><div id = "collapsible17">{
		if (argv[i][0] == '/') <button id="collapseInfo" onclick ="myFunction('collapsible18')">show</button><div id = "collapsible18">{
			options_.push_back(argv[i][1]);
			std::cout &lt;&lt;"1-"&lt;&lt; argv[i][1]&lt;&lt;"\n";
		}</div>
		else <button id="collapseInfo" onclick ="myFunction('collapsible19')">show</button><div id = "collapsible19">{
			std::string temp = argv[i];
			patterns_.push_back(argv[i]);
		}</div>
    }</div>
    if (patterns_.size() == 0)
    <button id="collapseInfo" onclick ="myFunction('collapsible20')">show</button><div id = "collapsible20">{
      showUsage();
      return false;
    }</div>
  }</div>
  catch (std::exception& ex)
  <button id="collapseInfo" onclick ="myFunction('collapsible21')">show</button><div id = "collapsible21">{
    std::cout &lt;&lt; "\n\n  command line argument parsing error:";
    std::cout &lt;&lt; "\n  " &lt;&lt; ex.what() &lt;&lt; "\n\n";
    return false;
  }</div>
  return true;
}</div>
//----&lt; returns path entered on command line &gt;-------------------

std::string CodeAnalysisExecutive::getAnalysisPath()
<button id="collapseInfo" onclick ="myFunction('collapsible22')">show</button><div id = "collapsible22">{
  return path_;
}</div>
//----&lt; returns reference to FileMap &gt;---------------------------
/*
 * Supports quickly finding all the files found with a give pattern
 */
FileMap& CodeAnalysisExecutive::getFileMap()
<button id="collapseInfo" onclick ="myFunction('collapsible23')">show</button><div id = "collapsible23">{
  return fileMap_;
}</div>
//----&lt; searches path for files matching specified patterns &gt;----
/*
 * - Searches entire diretory tree rooted at path_, evaluated 
 *   from a command line argument.
 * - Saves found files in FileMap.
 */
void CodeAnalysisExecutive::getSourceFiles()
<button id="collapseInfo" onclick ="myFunction('collapsible24')">show</button><div id = "collapsible24">{
  AnalFileMgr fm(path_, fileMap_);
  for (auto patt : patterns_)
    fm.addPattern(patt);
  fm.search();
  numFiles_ = fm.numFiles();
  numDirs_ = fm.numDirs();
}</div>
//----&lt; helper: is text a substring of str? &gt;--------------------

bool contains(const std::string& str, const std::string& text)
<button id="collapseInfo" onclick ="myFunction('collapsible25')">show</button><div id = "collapsible25">{
  if (str.find(text) &lt; str.length())
    return true;
  return false;
}</div>
//----&lt; retrieve from fileMap all files matching *.h &gt;-----------

std::vector&lt;File&gt;& CodeAnalysisExecutive::cppHeaderFiles()
<button id="collapseInfo" onclick ="myFunction('collapsible26')">show</button><div id = "collapsible26">{
  cppHeaderFiles_.clear();
  for (auto item : fileMap_)
  <button id="collapseInfo" onclick ="myFunction('collapsible27')">show</button><div id = "collapsible27">{
    if (contains(item.first, "*.h"))
    <button id="collapseInfo" onclick ="myFunction('collapsible28')">show</button><div id = "collapsible28">{
      for (auto file : item.second)
        cppHeaderFiles_.push_back(file);
    }</div>
  }</div>
  return cppHeaderFiles_;
}</div>
//----&lt; retrieve from fileMap all files matching *.cpp &gt;---------

std::vector&lt;File&gt;& CodeAnalysisExecutive::cppImplemFiles()
<button id="collapseInfo" onclick ="myFunction('collapsible29')">show</button><div id = "collapsible29">{
  cppImplemFiles_.clear();
  for (auto item : fileMap_)
  <button id="collapseInfo" onclick ="myFunction('collapsible30')">show</button><div id = "collapsible30">{
    if (contains(item.first, "*.cpp"))
    <button id="collapseInfo" onclick ="myFunction('collapsible31')">show</button><div id = "collapsible31">{
      for (auto file : item.second)
        cppImplemFiles_.push_back(file);
    }</div>
  }</div>
  return cppImplemFiles_;
}</div>
//----&lt; retrieve from fileMap all files matching *.cs &gt;----------

std::vector&lt;File&gt;& CodeAnalysisExecutive::csharpFiles()
<button id="collapseInfo" onclick ="myFunction('collapsible32')">show</button><div id = "collapsible32">{
  csharpFiles_.clear();
  for (auto item : fileMap_)
  <button id="collapseInfo" onclick ="myFunction('collapsible33')">show</button><div id = "collapsible33">{
    if (contains(item.first, "*.cs"))
    <button id="collapseInfo" onclick ="myFunction('collapsible34')">show</button><div id = "collapsible34">{
      for (auto file : item.second)
        csharpFiles_.push_back(file);
    }</div>
  }</div>
  return csharpFiles_;
}</div>
//----&lt; report number of Source Lines Of Code (SLOCs) &gt;----------

CodeAnalysisExecutive::Slocs CodeAnalysisExecutive::fileSLOCs(const File& file) 
<button id="collapseInfo" onclick ="myFunction('collapsible35')">show</button><div id = "collapsible35">{ 
  return slocMap_[file];
}</div>
//----&lt; report number of files processed &gt;-----------------------

size_t CodeAnalysisExecutive::numFiles()
<button id="collapseInfo" onclick ="myFunction('collapsible36')">show</button><div id = "collapsible36">{
  return numFiles_;
}</div>
//----&lt; report number of directories searched &gt;------------------

size_t CodeAnalysisExecutive::numDirs()
<button id="collapseInfo" onclick ="myFunction('collapsible37')">show</button><div id = "collapsible37">{
  return numDirs_;
}</div>
//----&lt; show processing activity &gt;-------------------------------

void CodeAnalysisExecutive::showActivity(const File& file)
<button id="collapseInfo" onclick ="myFunction('collapsible38')">show</button><div id = "collapsible38">{
  std::function&lt;std::string(std::string, size_t)&gt; trunc = [](std::string in, size_t count)
  <button id="collapseInfo" onclick ="myFunction('collapsible39')">show</button><div id = "collapsible39">{
    return in.substr(0, count);
  }59</div>

  if (Rslt::running())
  <button id="collapseInfo" onclick ="myFunction('collapsible40')">show</button><div id = "collapsible40">{
    std::cout &lt;&lt; std::left &lt;&lt; "\r     Processing file: " &lt;&lt; std::setw(80) &lt;&lt; trunc(file, 80);
  }</div>
}</div>

void CodeAnalysisExecutive::clearActivity()
<button id="collapseInfo" onclick ="myFunction('collapsible41')">show</button><div id = "collapsible41">{
  if (Rslt::running())
  <button id="collapseInfo" onclick ="myFunction('collapsible42')">show</button><div id = "collapsible42">{
    std::cout &lt;&lt; std::left &lt;&lt; "\r                      " &lt;&lt; std::setw(80) &lt;&lt; std::string(80,' ');
  }</div>
}</div>
//----&lt; parses code and saves results in AbstrSynTree &gt;--------------
/*
* - Processes C++ header files first to build AST with nodes for
*   all public classes and structs.
* - Then processes C++ implementation files.  Each member function
*   is relocated to its class scope node, not the local scope.
* - Therefore, this ordering is important.
* - C# code has all member functions inline, so we don't need to
*   do any relocation of nodes in the AST.  Therefore, that analysis
*   can be done at any time.
* - If you bore down into the analysis code in ActionsAndRules.h you
*   will find some gymnastics to handle template syntax.  That can
*   get somewhat complicated, so there may be some latent bugs there.
*   I don't know of any at this time.
*/
void CodeAnalysisExecutive::setLanguage(const File& file)
<button id="collapseInfo" onclick ="myFunction('collapsible43')">show</button><div id = "collapsible43">{
  std::string ext = FileSystem::Path::getExt(file);
  if (ext == "h" || ext == "cpp")
    pRepo_-&gt;language() = Language::Cpp;
  else if (ext == "cs")
    pRepo_-&gt;language() = Language::CSharp;
}</div>
void CodeAnalysisExecutive::processCppHeaderFiles(bool showProc) <button id="collapseInfo" onclick ="myFunction('collapsible44')">show</button><div id = "collapsible44">{
	for (auto file : cppHeaderFiles())
	<button id="collapseInfo" onclick ="myFunction('collapsible45')">show</button><div id = "collapsible45">{
		if (showProc)
			showActivity(file);
		pRepo_-&gt;package() = FileSystem::Path::getName(file);
		if (!configure_.Attach(file))
		<button id="collapseInfo" onclick ="myFunction('collapsible46')">show</button><div id = "collapsible46">{
			std::ostringstream out;
			out &lt;&lt; "\n  could not open file " &lt;&lt; file &lt;&lt; "\n";
			Rslt::write(out.str());
			Rslt::flush();
			continue;
		}</div> // parse file
		Rslt::flush();
		Demo::flush();
		Dbug::flush();
		if (!Rslt::running())
			Demo::write("\n\n  opening file \"" + pRepo_-&gt;package() + "\"");
		if (!Demo::running() && !Rslt::running())
			Dbug::write("\n\n  opening file \"" + pRepo_-&gt;package() + "\"");
		pRepo_-&gt;language() = Language::Cpp;
		pRepo_-&gt;currentPath() = file;
		while (pParser_-&gt;next())
		<button id="collapseInfo" onclick ="myFunction('collapsible47')">show</button><div id = "collapsible47">{
			pParser_-&gt;parse();
		}</div>
		Slocs slocs = pRepo_-&gt;Toker()-&gt;currentLineCount();
		slocMap_[pRepo_-&gt;package()] = slocs;
	}</div>
}</div>
void CodeAnalysisExecutive::processCppImplemFiles(bool showProc) <button id="collapseInfo" onclick ="myFunction('collapsible48')">show</button><div id = "collapsible48">{
	for (auto file : cppImplemFiles())
	<button id="collapseInfo" onclick ="myFunction('collapsible49')">show</button><div id = "collapsible49">{
		if (showProc)
			showActivity(file);
		pRepo_-&gt;package() = FileSystem::Path::getName(file);

		if (!configure_.Attach(file))
		<button id="collapseInfo" onclick ="myFunction('collapsible50')">show</button><div id = "collapsible50">{
			std::ostringstream out;
			out &lt;&lt; "\n  could not open file " &lt;&lt; file &lt;&lt; "\n";
			Rslt::write(out.str());
			Rslt::flush();
			continue;
		}</div> // parse file
		if (!Rslt::running())
			Demo::write("\n\n  opening file \"" + pRepo_-&gt;package() + "\"");
		if (!Demo::running() && !Rslt::running())
			Dbug::write("\n\n  opening file \"" + pRepo_-&gt;package() + "\"");
		pRepo_-&gt;language() = Language::Cpp;
		pRepo_-&gt;currentPath() = file;
		while (pParser_-&gt;next())
			pParser_-&gt;parse();

		Slocs slocs = pRepo_-&gt;Toker()-&gt;currentLineCount();
		slocMap_[pRepo_-&gt;package()] = slocs;
	}</div>
}</div>
void CodeAnalysisExecutive::processCsharpFiles(bool showProc) <button id="collapseInfo" onclick ="myFunction('collapsible51')">show</button><div id = "collapsible51">{
	for (auto file : csharpFiles())
	<button id="collapseInfo" onclick ="myFunction('collapsible52')">show</button><div id = "collapsible52">{
		if (showProc)
			showActivity(file);
		pRepo_-&gt;package() = FileSystem::Path::getName(file);
		if (!configure_.Attach(file))
		<button id="collapseInfo" onclick ="myFunction('collapsible53')">show</button><div id = "collapsible53">{
			std::ostringstream out;
			out &lt;&lt; "\n  could not open file " &lt;&lt; file &lt;&lt; "\n";
			Rslt::write(out.str());
			continue;
		}</div>// parse file
		if (!Rslt::running())
			Demo::write("\n\n  opening file \"" + pRepo_-&gt;package() + "\"");
		if (!Demo::running() && !Rslt::running())
			Dbug::write("\n\n  opening file \"" + pRepo_-&gt;package() + "\"");
		pRepo_-&gt;language() = Language::CSharp;
		pRepo_-&gt;currentPath() = file;
		while (pParser_-&gt;next())
			pParser_-&gt;parse();
		Slocs slocs = pRepo_-&gt;Toker()-&gt;currentLineCount();
		slocMap_[pRepo_-&gt;package()] = slocs;
	}</div>
}</div>
void CodeAnalysisExecutive::processSourceCode(bool showProc)
<button id="collapseInfo" onclick ="myFunction('collapsible54')">show</button><div id = "collapsible54">{
	processCppHeaderFiles(showProc);
	processCppImplemFiles(showProc);
	processCsharpFiles(showProc);
  if (showProc)
    clearActivity();
  std::ostringstream out;
  out &lt;&lt; std::left &lt;&lt; "\r  " &lt;&lt; std::setw(77) &lt;&lt; " ";
  Rslt::write(out.str());
}</div>
//----&lt; evaluate complexities of each AST node &gt;---------------------

void CodeAnalysisExecutive::complexityAnalysis()
<button id="collapseInfo" onclick ="myFunction('collapsible55')">show</button><div id = "collapsible55">{
  ASTNode* pGlobalScope = pRepo_-&gt;getGlobalScope();
  CodeAnalysis::complexityEval(pGlobalScope);
}</div>
//----&lt; comparison functor for sorting FileToNodeCollection &gt;----
/*
* - supports stable sort on extension values
* - displayMetrics(...) uses to organize metrics display
*/
struct CompExts
<button id="collapseInfo" onclick ="myFunction('collapsible56')">show</button><div id = "collapsible56">{
  bool operator()(const std::pair&lt;File, ASTNode*&gt;& first, const std::pair&lt;File, ASTNode*&gt;& second)
  <button id="collapseInfo" onclick ="myFunction('collapsible57')">show</button><div id = "collapsible57">{
    return FileSystem::Path::getExt(first.first) &gt; FileSystem::Path::getExt(second.first);
  }</div>
}59</div>
//----&lt; comparison functor for sorting FileToNodeCollection &gt;----
/*
* - supports stable sort on name values
* - displayMetrics(...) uses these functions to organize metrics display
*/
static void removeExt(std::string& name)
<button id="collapseInfo" onclick ="myFunction('collapsible58')">show</button><div id = "collapsible58">{
  size_t extStartIndex = name.find_last_of('.');
  name = name.substr(0, extStartIndex);
}</div>

struct CompNames
<button id="collapseInfo" onclick ="myFunction('collapsible59')">show</button><div id = "collapsible59">{
  bool operator()(const std::pair&lt;File, ASTNode*&gt;& first, const std::pair&lt;File, ASTNode*&gt;& second)
  <button id="collapseInfo" onclick ="myFunction('collapsible60')">show</button><div id = "collapsible60">{
    std::string fnm = FileSystem::Path::getName(first.first);
    removeExt(fnm);
    std::string snm = FileSystem::Path::getName(second.first);
    removeExt(snm);
    return fnm &lt; snm;
  }</div>
}59</div>
//----&lt; display header line for displayMmetrics() &gt;------------------

void CodeAnalysisExecutive::displayHeader()
<button id="collapseInfo" onclick ="myFunction('collapsible61')">show</button><div id = "collapsible61">{
  std::ostringstream out;
  out &lt;&lt; std::right;
  out &lt;&lt; "\n ";
  out &lt;&lt; std::setw(25) &lt;&lt; "file name";
  out &lt;&lt; std::setw(12) &lt;&lt; "type";
  out &lt;&lt; std::setw(35) &lt;&lt; "name";
  out &lt;&lt; std::setw(8) &lt;&lt; "line";
  out &lt;&lt; std::setw(8) &lt;&lt; "size";
  out &lt;&lt; std::setw(8) &lt;&lt; "cplx";
  out &lt;&lt; std::right;
  out &lt;&lt; "\n  ";
  out &lt;&lt; std::setw(25) &lt;&lt; "-----------------------";
  out &lt;&lt; std::setw(12) &lt;&lt; "----------";
  out &lt;&lt; std::setw(35) &lt;&lt; "---------------------------------";
  out &lt;&lt; std::setw(8) &lt;&lt; "------";
  out &lt;&lt; std::setw(8) &lt;&lt; "------";
  out &lt;&lt; std::setw(8) &lt;&lt; "------";
  Rslt::write(out.str());
}</div>
//----&lt; display single line for displayMetrics() &gt;-------------------

void CodeAnalysisExecutive::displayMetricsLine(const File& file, ASTNode* pNode)
<button id="collapseInfo" onclick ="myFunction('collapsible62')">show</button><div id = "collapsible62">{
  std::function&lt;std::string(std::string, size_t)&gt; trunc = [](std::string in, size_t count)
  <button id="collapseInfo" onclick ="myFunction('collapsible63')">show</button><div id = "collapsible63">{
    return in.substr(0, count);
  }59</div>
  std::ostringstream out;
  out &lt;&lt; std::right;
  out &lt;&lt; "\n ";
  out &lt;&lt; std::setw(25) &lt;&lt; trunc(file, 23);
  out &lt;&lt; std::setw(12) &lt;&lt; pNode-&gt;type_;
  out &lt;&lt; std::setw(35) &lt;&lt; trunc(pNode-&gt;name_, 33);
  out &lt;&lt; std::setw(8) &lt;&lt; pNode-&gt;startLineCount_;
  out &lt;&lt; std::setw(8) &lt;&lt; pNode-&gt;endLineCount_ - pNode-&gt;startLineCount_ + 1;
  size_t debug1 = pNode-&gt;startLineCount_;
  size_t debug2 = pNode-&gt;endLineCount_;
  out &lt;&lt; std::setw(8) &lt;&lt; pNode-&gt;complexity_;
  Rslt::write(out.str());
}</div>
//----&lt; display lines containing public data declaration &gt;-----------

std::string CodeAnalysisExecutive::showData(const Scanner::ITokCollection* pTc)
<button id="collapseInfo" onclick ="myFunction('collapsible64')">show</button><div id = "collapsible64">{
  std::string semiExpStr;
  for (size_t i=0; i&lt;pTc-&gt;length(); ++i)
    semiExpStr += (*pTc)[i] + " ";
  return semiExpStr;
}</div>

void CodeAnalysisExecutive::displayDataLines(ASTNode* pNode, bool isSummary)
<button id="collapseInfo" onclick ="myFunction('collapsible65')">show</button><div id = "collapsible65">{
  for (auto datum : pNode-&gt;decl_)
  <button id="collapseInfo" onclick ="myFunction('collapsible66')">show</button><div id = "collapsible66">{
    if (pNode-&gt;type_ == "function")
      continue;
    if (datum.access_ == Access::publ && datum.declType_ == DeclType::dataDecl)
    <button id="collapseInfo" onclick ="myFunction('collapsible67')">show</button><div id = "collapsible67">{
      std::ostringstream out;
      out &lt;&lt; std::right;
      out &lt;&lt; "\n ";
      out &lt;&lt; std::setw(25) &lt;&lt; "public data:" &lt;&lt; " ";
      if (isSummary)
      <button id="collapseInfo" onclick ="myFunction('collapsible68')">show</button><div id = "collapsible68">{
        out &lt;&lt; datum.package_ &lt;&lt; " : " &lt;&lt; datum.line_ &lt;&lt; " - " 
          &lt;&lt; pNode-&gt;type_ &lt;&lt; " " &lt;&lt; pNode-&gt;name_ &lt;&lt; "\n " &lt;&lt; std::setw(15) &lt;&lt; " ";
      }</div>
      out &lt;&lt; showData(datum.pTc);
      Rslt::write(out.str());
    }</div>
  }</div>
}</div>
//----&lt;  helper for displayMetrics() &gt;-------------------------------
/*
* - Breaking this out as a separate function allows application to
*   display metrics for a subset of the Abstract Syntax Tree
*/
void CodeAnalysisExecutive::displayMetrics(ASTNode* root)
<button id="collapseInfo" onclick ="myFunction('collapsible69')">show</button><div id = "collapsible69">{
  flushLogger();
  std::ostringstream out;
  out &lt;&lt; "Code Metrics - Start Line, Size (lines/code), and Complexity (number of scopes)";
  Utils::sTitle(out.str(), 3, 92, out, '=');
  out &lt;&lt; "\n";
  Rslt::write(out.str());

  std::function&lt;void(ASTNode* pNode)&gt; co = [&](ASTNode* pNode) <button id="collapseInfo" onclick ="myFunction('collapsible70')">show</button><div id = "collapsible70">{
    if (
      pNode-&gt;type_ == "namespace" ||
      pNode-&gt;type_ == "function" ||
      pNode-&gt;type_ == "class" ||
      pNode-&gt;type_ == "interface" ||
      pNode-&gt;type_ == "struct" ||
      pNode-&gt;type_ == "lambda"
      )
      fileNodes_.push_back(std::pair&lt;File, ASTNode*&gt;(pNode-&gt;package_, pNode));
  }59</div>
  ASTWalkNoIndent(root, co);
  std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompExts());
  std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompNames());

  displayHeader();

  std::string prevFile;
  for (auto item : fileNodes_)
  <button id="collapseInfo" onclick ="myFunction('collapsible71')">show</button><div id = "collapsible71">{
    if (item.first != prevFile)
    <button id="collapseInfo" onclick ="myFunction('collapsible72')">show</button><div id = "collapsible72">{
      Rslt::write("\n");
      displayHeader();
    }</div>
    displayMetricsLine(item.first, item.second);
    displayDataLines(item.second);
    prevFile = item.first;
  }</div>
  Rslt::write("\n");
}</div>
//----&lt; display metrics results of code analysis &gt;---------------

void CodeAnalysisExecutive::displayMetrics()
<button id="collapseInfo" onclick ="myFunction('collapsible73')">show</button><div id = "collapsible73">{
  ASTNode* pGlobalScope = pRepo_-&gt;getGlobalScope();
  displayMetrics(pGlobalScope);
}</div>
//----&lt; walk tree of element nodes &gt;---------------------------------

template&lt;typename element&gt;
void TreeWalk(element* pItem, bool details = false)
<button id="collapseInfo" onclick ="myFunction('collapsible74')">show</button><div id = "collapsible74">{
  static std::string path;
  if (path != pItem-&gt;path_ && details == true)
  <button id="collapseInfo" onclick ="myFunction('collapsible75')">show</button><div id = "collapsible75">{
    path = pItem-&gt;path_;
    Rslt::write("\n" + path);
  }</div>
  static size_t indentLevel = 0;
  std::ostringstream out;
  out &lt;&lt; "\n  " &lt;&lt; std::string(2 * indentLevel, ' ') &lt;&lt; pItem-&gt;show();
  Rslt::write(out.str());
  auto iter = pItem-&gt;children_.begin();
  ++indentLevel;
  while (iter != pItem-&gt;children_.end())
  <button id="collapseInfo" onclick ="myFunction('collapsible76')">show</button><div id = "collapsible76">{
    TreeWalk(*iter);
    ++iter;
  }</div>
  --indentLevel;
}</div>
//----&lt; display the AbstrSynTree build in processSourceCode() &gt;------

void CodeAnalysisExecutive::displayAST()
<button id="collapseInfo" onclick ="myFunction('collapsible77')">show</button><div id = "collapsible77">{
  flushLogger();
  ASTNode* pGlobalScope = pRepo_-&gt;getGlobalScope();
  Utils::title("Abstract Syntax Tree");
  TreeWalk(pGlobalScope);
  Rslt::write("\n");
}</div>
//----&lt; show functions with metrics exceeding specified limits &gt;-----

void CodeAnalysisExecutive::displayMetricSummary(size_t sMax, size_t cMax)
<button id="collapseInfo" onclick ="myFunction('collapsible78')">show</button><div id = "collapsible78">{
  flushLogger();
  std::ostringstream out;
  Utils::sTitle("Functions Exceeding Metric Limits and Public Data", 3, 92, out, '=');
  Rslt::write(out.str());
  displayHeader();

  if (fileNodes_.size() == 0)  // only build fileNodes_ if displayMetrics hasn't been called
  <button id="collapseInfo" onclick ="myFunction('collapsible79')">show</button><div id = "collapsible79">{
    std::function&lt;void(ASTNode* pNode)&gt; co = [&](ASTNode* pNode) <button id="collapseInfo" onclick ="myFunction('collapsible80')">show</button><div id = "collapsible80">{
      fileNodes_.push_back(std::pair&lt;File, ASTNode*&gt;(pNode-&gt;package_, pNode));
    }59</div>
    ASTNode* pGlobalNamespace = pRepo_-&gt;getGlobalScope();
    ASTWalkNoIndent(pGlobalNamespace, co);
    std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompExts());
    std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompNames());
  }</div>
  for (auto item : fileNodes_)
  <button id="collapseInfo" onclick ="myFunction('collapsible81')">show</button><div id = "collapsible81">{
    if (item.second-&gt;type_ == "function")
    <button id="collapseInfo" onclick ="myFunction('collapsible82')">show</button><div id = "collapsible82">{
      size_t size = item.second-&gt;endLineCount_ - item.second-&gt;startLineCount_ + 1;
      size_t cmpl = item.second-&gt;complexity_;
      if (size &gt; sMax || cmpl &gt; cMax)
        displayMetricsLine(item.first, item.second);
    }</div>
  }</div>
  Rslt::write("\n");
  for (auto item : fileNodes_)
  <button id="collapseInfo" onclick ="myFunction('collapsible83')">show</button><div id = "collapsible83">{
    displayDataLines(item.second, true);
  }</div>
  Rslt::write("\n");
}</div>
//----&lt; comparison functor for sorting SLOC display &gt;----------------

struct compFiles
<button id="collapseInfo" onclick ="myFunction('collapsible84')">show</button><div id = "collapsible84">{
private:
  std::string ChangeFirstCharOfExt(const std::string& fileName) const
  <button id="collapseInfo" onclick ="myFunction('collapsible85')">show</button><div id = "collapsible85">{
    std::string temp = fileName;
    size_t pos = temp.find_last_of('.');
    if (pos &lt; temp.size() - 1)
      if (temp[pos + 1] == 'h')
        temp[pos + 1] = 'a';
    return temp;
  }</div>
public:
  bool operator()(const std::string& fileName1, const std::string& fileName2) const
  <button id="collapseInfo" onclick ="myFunction('collapsible86')">show</button><div id = "collapsible86">{
    return ChangeFirstCharOfExt(fileName1) &lt; ChangeFirstCharOfExt(fileName2);
  }</div>
}59</div>
//----&lt; show sizes of all the files processed &gt;----------------------

void CodeAnalysisExecutive::displaySlocs()
<button id="collapseInfo" onclick ="myFunction('collapsible87')">show</button><div id = "collapsible87">{
  flushLogger();
  Utils::sTitle("File Size - Source Lines of Code", 3, 92);
  size_t slocCount = 0;
  std::map&lt;std::string, size_t, compFiles&gt; fileColl;
  for (auto item : fileMap_)
  <button id="collapseInfo" onclick ="myFunction('collapsible88')">show</button><div id = "collapsible88">{
    for (auto file : item.second)
    <button id="collapseInfo" onclick ="myFunction('collapsible89')">show</button><div id = "collapsible89">{
      File fileName = FileSystem::Path::getName(file);
      fileColl[file] = slocMap_[fileName];
    }</div>
  }</div>
  for (auto fitem : fileColl)
  <button id="collapseInfo" onclick ="myFunction('collapsible90')">show</button><div id = "collapsible90">{
    std::ostringstream out;
    out &lt;&lt; "\n  " &lt;&lt; std::setw(8) &lt;&lt; fitem.second &lt;&lt; " : " &lt;&lt; fitem.first;
    Rslt::write(out.str());
    slocCount += fitem.second;
  }</div>
  std::ostringstream out;
  out &lt;&lt; "\n\n      Total line count = " &lt;&lt; slocCount &lt;&lt; "\n";
  Rslt::write(out.str());
  Rslt::write("\n");
}</div>
//----&lt; display analysis info based on command line options &gt;--------

void CodeAnalysisExecutive::dispatchOptionalDisplays()
<button id="collapseInfo" onclick ="myFunction('collapsible91')">show</button><div id = "collapsible91">{
  for (auto opt : options_)
  <button id="collapseInfo" onclick ="myFunction('collapsible92')">show</button><div id = "collapsible92">{
    switch (opt)
    <button id="collapseInfo" onclick ="myFunction('collapsible93')">show</button><div id = "collapsible93">{
    case 'm':
      displayMetrics();
      Rslt::start();
      break;
    case 'a':
      displayAST();
      Rslt::start();
      break;
    case 's':
      displaySlocs();
      Rslt::start();
      break;
    default:
      break;
    }</div>
  }</div>
}</div>
//----&lt; display analysis info based on command line options &gt;--------

void CodeAnalysisExecutive::setDisplayModes()
<button id="collapseInfo" onclick ="myFunction('collapsible94')">show</button><div id = "collapsible94">{
  for (auto opt : options_)
  <button id="collapseInfo" onclick ="myFunction('collapsible95')">show</button><div id = "collapsible95">{
    switch (opt)
    <button id="collapseInfo" onclick ="myFunction('collapsible96')">show</button><div id = "collapsible96">{
    case 'r':
      Rslt::start();
      break;
    case 'd':
      Demo::start();
      break;
    case 'b':
      Dbug::start();
      break;
    case 'f':
      setLogFile("logFile.txt");
      break;
    default:
      if (opt != 'a' && opt != 'b' && opt != 'd' && opt != 'f' && opt != 'm' && opt != 'r' && opt != 's')
      <button id="collapseInfo" onclick ="myFunction('collapsible97')">show</button><div id = "collapsible97">{
        std::cout &lt;&lt; "\n\n  unknown option " &lt;&lt; opt &lt;&lt; "\n\n";
      }</div>
    }</div>
  }</div>
}</div>
//----&lt; helper functions for managing application's logging &gt;--------

void CodeAnalysisExecutive::startLogger(std::ostream& out)
<button id="collapseInfo" onclick ="myFunction('collapsible98')">show</button><div id = "collapsible98">{
  Rslt::attach(&out);
  Demo::attach(&out);
  Dbug::attach(&out);

  // will start Demo and Dbug if  have options /d and /b

  setDisplayModes();
}</div>

void CodeAnalysisExecutive::flushLogger()
<button id="collapseInfo" onclick ="myFunction('collapsible99')">show</button><div id = "collapsible99">{
  Rslt::flush();
  Demo::flush();
  Dbug::flush();
}</div>

void CodeAnalysisExecutive::stopLogger()
<button id="collapseInfo" onclick ="myFunction('collapsible100')">show</button><div id = "collapsible100">{
  Rslt::flush();
  Demo::flush();
  Dbug::flush();
  Rslt::stop();
  Demo::stop();
  Dbug::stop();
}</div>
//----&lt; open file stream for logging &gt;-------------------------------
/*
*  - must come after CodeAnalysisExecutive::processCommandLine()
*  - must come before starting any of the loggers
*/
void CodeAnalysisExecutive::setLogFile(const File& file)
<button id="collapseInfo" onclick ="myFunction('collapsible101')">show</button><div id = "collapsible101">{
  std::string path = getAnalysisPath();
  path += "\\" + file;
  pLogStrm_ = new std::ofstream(path);
  if (pLogStrm_-&gt;good())
  <button id="collapseInfo" onclick ="myFunction('collapsible102')">show</button><div id = "collapsible102">{
    Rslt::attach(pLogStrm_);
    Demo::attach(pLogStrm_);
    Dbug::attach(pLogStrm_);
  }</div>
  else
    Rslt::write("\n  couldn't open logFile.txt for writing");
}</div>

std::string CodeAnalysisExecutive::systemTime()
<button id="collapseInfo" onclick ="myFunction('collapsible103')">show</button><div id = "collapsible103">{ 
  time_t sysTime = time(&sysTime);
  char buffer[27];
  ctime_s(buffer, 27, &sysTime);
  buffer[24] = '\0';
  std::string temp(buffer);
  return temp;
}</div>

void CodeAnalysisExecutive::performAnalysis() <button id="collapseInfo" onclick ="myFunction('collapsible104')">show</button><div id = "collapsible104">{
	std::cout &lt;&lt; "\n-------------------------------------------------------------------------------\n";
	std::cout &lt;&lt; "\n  Code Analysis completed- Abstract syntax Tree generated\n";
	std::cout &lt;&lt; "\n   Performed Type Analysis and Depandancy Analysis on the files in the package\n";
	std::cout &lt;&lt; "\n-------------------------------------------------------------------------------\n";
	Display d;
	d.typeAnalysis();
	d.depAnalysis();
	d.depDatabase();
	d.publishFiles();

}</div>
//----&lt; conduct code analysis &gt;--------------------------------------

#include &lt;fstream&gt;

int main(int argc, char* argv[])
<button id="collapseInfo" onclick ="myFunction('collapsible105')">show</button><div id = "collapsible105">{
	std::cout &lt;&lt; "\n-------Requirement 1- Running the program on Visual studio 2015------------------------\n\n";
	std::cout &lt;&lt; "--------Requirement 10 - Running automated test unit------------------------------\n\n";
  using namespace CodeAnalysis;
  CodeAnalysisExecutive exec;
  try <button id="collapseInfo" onclick ="myFunction('collapsible106')">show</button><div id = "collapsible106">{
    bool succeeded = exec.ProcessCommandLine(argc, argv);
    if (!succeeded)
    <button id="collapseInfo" onclick ="myFunction('collapsible107')">show</button><div id = "collapsible107">{
      return 1;
    }</div>
    exec.setDisplayModes();
    exec.startLogger(std::cout);
    std::ostringstream tOut("CodeAnalysis");
    Utils::sTitle(tOut.str(), 3, 92, tOut, '=');
    Rslt::write(tOut.str());
    //Rslt::write("\n     " + exec.getAnalysisPath());
    Rslt::write("\n     " + exec.systemTime());
    Rslt::flush();
	std::cout &lt;&lt; "\n------------------Requirement 8- Command lines Aruments taken by the program are---------------";
    exec.showCommandLineArguments(argc, argv);
	Rslt::write("\n");
    exec.getSourceFiles();
    exec.processSourceCode(true);
    exec.complexityAnalysis();
    exec.dispatchOptionalDisplays();
    exec.flushLogger();
    exec.displayMetricSummary(50,10);
    exec.flushLogger();
    Rslt::write("\n");
    std::ostringstream out;
    out &lt;&lt; "\n  " &lt;&lt; std::setw(10) &lt;&lt; "searched" &lt;&lt; std::setw(6) &lt;&lt; exec.numDirs() &lt;&lt; " dirs";
    out &lt;&lt; "\n  " &lt;&lt; std::setw(10) &lt;&lt; "processed" &lt;&lt; std::setw(6) &lt;&lt; exec.numFiles() &lt;&lt; " files";
    Rslt::write(out.str());
    Rslt::write("\n");
    exec.stopLogger();
	exec.performAnalysis();
  }</div>
  catch (std::exception& except)
  <button id="collapseInfo" onclick ="myFunction('collapsible108')">show</button><div id = "collapsible108">{
    exec.flushLogger();
    std::cout &lt;&lt; "\n\n  caught exception in Executive::main: " + std::string(except.what()) + "\n\n";
    exec.stopLogger();
    return 1;
  }</div>
  return 0;
}</div></pre></div><div class='footer'><a class='acolor'href='mainPage.html'>Return to main page</a><div class='alignRight'>&copy;&nbsp;Copyright 2017. All rights reserved</div></div></body>